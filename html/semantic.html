<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器相关 | TimeLine</title>
    <meta name="description" content="记录我的前端学习点滴">
    <meta name="generator" content="VuePress 1.3.0">
    
    
    <link rel="preload" href="/mblog/assets/css/0.styles.c6272ac7.css" as="style"><link rel="preload" href="/mblog/assets/js/app.b34711a8.js" as="script"><link rel="preload" href="/mblog/assets/js/2.1254f33f.js" as="script"><link rel="preload" href="/mblog/assets/js/14.1f383059.js" as="script"><link rel="preload" href="/mblog/assets/js/4.4f648c2b.js" as="script"><link rel="prefetch" href="/mblog/assets/js/10.5d5957c8.js"><link rel="prefetch" href="/mblog/assets/js/11.4194f877.js"><link rel="prefetch" href="/mblog/assets/js/12.f3819994.js"><link rel="prefetch" href="/mblog/assets/js/13.3b3fceb3.js"><link rel="prefetch" href="/mblog/assets/js/15.4d559c4b.js"><link rel="prefetch" href="/mblog/assets/js/16.e45fcdbd.js"><link rel="prefetch" href="/mblog/assets/js/17.c8e38934.js"><link rel="prefetch" href="/mblog/assets/js/18.fe8b93a5.js"><link rel="prefetch" href="/mblog/assets/js/19.0971f681.js"><link rel="prefetch" href="/mblog/assets/js/20.90de0776.js"><link rel="prefetch" href="/mblog/assets/js/21.4d432eb3.js"><link rel="prefetch" href="/mblog/assets/js/22.f1a67874.js"><link rel="prefetch" href="/mblog/assets/js/23.d8ef03c4.js"><link rel="prefetch" href="/mblog/assets/js/24.407ee46f.js"><link rel="prefetch" href="/mblog/assets/js/25.1febc119.js"><link rel="prefetch" href="/mblog/assets/js/26.c5c74c02.js"><link rel="prefetch" href="/mblog/assets/js/27.7fa9686b.js"><link rel="prefetch" href="/mblog/assets/js/28.e3ea476f.js"><link rel="prefetch" href="/mblog/assets/js/29.ce04160a.js"><link rel="prefetch" href="/mblog/assets/js/3.14617ffe.js"><link rel="prefetch" href="/mblog/assets/js/30.b61f8116.js"><link rel="prefetch" href="/mblog/assets/js/31.87e03a7c.js"><link rel="prefetch" href="/mblog/assets/js/5.3126dc46.js"><link rel="prefetch" href="/mblog/assets/js/6.f7b5ac92.js"><link rel="prefetch" href="/mblog/assets/js/7.2299856a.js"><link rel="prefetch" href="/mblog/assets/js/8.3b6fc075.js"><link rel="prefetch" href="/mblog/assets/js/9.cc8a5821.js">
    <link rel="stylesheet" href="/mblog/assets/css/0.styles.c6272ac7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/mblog/" class="home-link router-link-active"><!----> <span class="site-name">TimeLine</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="笔记" class="dropdown-title"><span class="title">笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Basic
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/mblog/html/semantic/" class="nav-link">
  HTML
</a></li><li class="dropdown-subitem"><a href="/mblog/js/closures/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-subitem"><a href="/mblog/css/cssskill/" class="nav-link">
  CSS
</a></li><li class="dropdown-subitem"><a href="/mblog/node/node/" class="nav-link">
  Node
</a></li></ul></li><li class="dropdown-item"><h4>
          Framework
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/mblog/vue/lifecycle/" class="nav-link">
  Vue
</a></li><li class="dropdown-subitem"><a href="/mblog/flutter/basic.html" class="nav-link">
  Flutter
</a></li></ul></li><li class="dropdown-item"><h4>
          Network
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/mblog/network/http/" class="nav-link">
  HTTP
</a></li></ul></li><li class="dropdown-item"><h4>
          Plan
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/mblog/plan/note/" class="nav-link">
  note
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="书籍" class="dropdown-title"><span class="title">书籍</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mblog/textbook/parsehttp/" class="nav-link">
  图解HTTP
</a></li><li class="dropdown-item"><!----> <a href="/mblog/textbook/computerNetworks/" class="nav-link">
  计算机网络教程
</a></li><li class="dropdown-item"><!----> <a href="/mblog/textbook/compute/" class="nav-link">
  计算的本质
</a></li><li class="dropdown-item"><!----> <a href="/mblog/textbook/advance/" class="nav-link">
  JS高级程序设计
</a></li></ul></div></div><div class="nav-item"><a href="/mblog/echo/echo/" class="nav-link">
  环境安装
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="笔记" class="dropdown-title"><span class="title">笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Basic
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/mblog/html/semantic/" class="nav-link">
  HTML
</a></li><li class="dropdown-subitem"><a href="/mblog/js/closures/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-subitem"><a href="/mblog/css/cssskill/" class="nav-link">
  CSS
</a></li><li class="dropdown-subitem"><a href="/mblog/node/node/" class="nav-link">
  Node
</a></li></ul></li><li class="dropdown-item"><h4>
          Framework
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/mblog/vue/lifecycle/" class="nav-link">
  Vue
</a></li><li class="dropdown-subitem"><a href="/mblog/flutter/basic.html" class="nav-link">
  Flutter
</a></li></ul></li><li class="dropdown-item"><h4>
          Network
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/mblog/network/http/" class="nav-link">
  HTTP
</a></li></ul></li><li class="dropdown-item"><h4>
          Plan
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/mblog/plan/note/" class="nav-link">
  note
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="书籍" class="dropdown-title"><span class="title">书籍</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mblog/textbook/parsehttp/" class="nav-link">
  图解HTTP
</a></li><li class="dropdown-item"><!----> <a href="/mblog/textbook/computerNetworks/" class="nav-link">
  计算机网络教程
</a></li><li class="dropdown-item"><!----> <a href="/mblog/textbook/compute/" class="nav-link">
  计算的本质
</a></li><li class="dropdown-item"><!----> <a href="/mblog/textbook/advance/" class="nav-link">
  JS高级程序设计
</a></li></ul></div></div><div class="nav-item"><a href="/mblog/echo/echo/" class="nav-link">
  环境安装
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>浏览器相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/mblog/html/semantic.html#浏览器页面渲染机制" class="sidebar-link">浏览器页面渲染机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mblog/html/semantic.html#浏览器内核" class="sidebar-link">浏览器内核</a></li><li class="sidebar-sub-header"><a href="/mblog/html/semantic.html#页面加载过程（简）" class="sidebar-link">页面加载过程（简）</a></li><li class="sidebar-sub-header"><a href="/mblog/html/semantic.html#浏览器渲染过程" class="sidebar-link">浏览器渲染过程</a></li><li class="sidebar-sub-header"><a href="/mblog/html/semantic.html#构建-dom" class="sidebar-link">构建 DOM</a></li><li class="sidebar-sub-header"><a href="/mblog/html/semantic.html#构建-cssom" class="sidebar-link">构建 CSSOM</a></li><li class="sidebar-sub-header"><a href="/mblog/html/semantic.html#构建渲染树（rendering-tree）" class="sidebar-link">构建渲染树（Rendering Tree）</a></li><li class="sidebar-sub-header"><a href="/mblog/html/semantic.html#布局与绘制" class="sidebar-link">布局与绘制</a></li><li class="sidebar-sub-header"><a href="/mblog/html/semantic.html#补充说明" class="sidebar-link">补充说明</a></li><li class="sidebar-sub-header"><a href="/mblog/html/semantic.html#性能优化策略" class="sidebar-link">性能优化策略</a></li><li class="sidebar-sub-header"><a href="/mblog/html/semantic.html#总结" class="sidebar-link">总结</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="浏览器相关"><a href="#浏览器相关" class="header-anchor">#</a> 浏览器相关</h1> <h2 id="浏览器页面渲染机制"><a href="#浏览器页面渲染机制" class="header-anchor">#</a> 浏览器页面渲染机制 <span class="badge tip" style="vertical-align:top;" data-v-15b7b770>转载</span></h2> <blockquote><p>来自<a href="https://mp.weixin.qq.com/s/Me7AHvCFDTaN24Qq9q2Jsg" target="_blank" rel="noopener noreferrer">前端开发 你不知道的浏览器页面渲染机制<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 以及部分摘自 <a href="https://juejin.im/post/5c15f797f265da61141c7f86" target="_blank" rel="noopener noreferrer">掘金 OBKoro1<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <h3 id="浏览器内核"><a href="#浏览器内核" class="header-anchor">#</a> 浏览器内核</h3> <p>浏览器的内核是指支持浏览器运行的最核心的程序，分为两个部分的，一是渲染引擎，另一个是 JS 引擎。</p> <h4 id="渲染引擎"><a href="#渲染引擎" class="header-anchor">#</a> 渲染引擎</h4> <p>渲染引擎在不同的浏览器中也不是都相同的。目前市面上常见的浏览器内核可以分为这四种：Trident（IE）、Gecko（火狐）、Blink（Chrome、Opera）、Webkit（Safari）。</p> <h3 id="页面加载过程（简）"><a href="#页面加载过程（简）" class="header-anchor">#</a> 页面加载过程（简）</h3> <ul><li>浏览器根据 DNS 服务器得到域名的 IP 地址</li> <li>向这个 IP 的机器发送 HTTP 请求</li> <li>服务器收到、处理并返回 HTTP 请求</li> <li>浏览器得到返回内容</li></ul> <h3 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="header-anchor">#</a> 浏览器渲染过程</h3> <p>大致分为三个部分</p> <ul><li>解析
<ol><li>HTML/SVG/XHTML，HTML 字符串描述了一个页面的结构，浏览器会把 HTML 结构字符串解析转换 DOM 树形结构。<a href="#%E6%9E%84%E5%BB%BA-dom">关于转换 DOM 树形结构，详见构建 DOM</a></li> <li>CSS，解析 CSS 会产生 CSS 规则树，它和 DOM 结构比较像。<a href="#%E6%9E%84%E5%BB%BA-cssom">关于产生 CSS 规则树，详见构建 CSSOM</a></li> <li>Javascript 脚本，等到 Javascript 脚本文件加载后， 通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree。</li></ol></li> <li>解析完成后，浏览器引擎会通过 DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree
<ul><li>Rendering Tree 渲染树并不等同于 DOM 树，渲染树只会包括需要显示的节点和这些节点的样式信息。<a href="#%E6%9E%84%E5%BB%BA%E6%B8%B2%E6%9F%93%E6%A0%91%EF%BC%88rendering-tree%EF%BC%89">关于 Rendering Tree 渲染树，详见构建渲染树</a></li> <li>CSS 的 Rule Tree 主要是为了完成匹配并把 CSS Rule 附加上 Rendering Tree 上的每个 Element（也就是每个 Frame）。</li> <li>然后，计算每个 Frame 的位置，这又叫 layout 和 reflow 过程。</li></ul></li> <li>最后通过调用操作系统 Native GUI 的 API 绘制</li></ul> <h3 id="构建-dom"><a href="#构建-dom" class="header-anchor">#</a> 构建 DOM</h3> <p>浏览器会遵守一套步骤将 HTML 文件转换为 DOM 树。宏观上，可以分为几个步骤：</p> <blockquote><p>字节数据-&gt;字符串-&gt;Token-&gt;Node-&gt;DOM</p></blockquote> <ul><li>浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成字符串。</li> <li>将字符串转换成 Token，例如： <code>&lt;html&gt;</code>、 <code>&lt;body&gt;</code>等。<strong>Token 中会标识出当前 Token 是“开始标签”或是“结束标签”亦或是“文本”等信息</strong>。</li> <li>生成节点对象(Node)并构建 DOM。</li></ul> <blockquote><p>在网络中传输的内容其实都是 0 和 1 这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码。</p></blockquote> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>事实上，构建 DOM 的过程中，不是等所有 Token 都转换完成后再去生成节点对象，而是一边生成 Token 一边消耗 Token 来生成节点对象。换句话说，每个 Token 被生成后，会立刻消耗这个 Token 创建出节点对象。<strong>注意：带有结束标签标识的 Token 不会创建节点对象</strong>。</p></div> <h3 id="构建-cssom"><a href="#构建-cssom" class="header-anchor">#</a> 构建 CSSOM</h3> <p>DOM 会捕获页面的内容，但浏览器还需要知道页面如何展示，所以需要构建 CSSOM。</p> <blockquote><p>字节数据-&gt;字符串-&gt;Token-&gt;Node-&gt;CSSOM</p></blockquote> <p>构建 CSSOM 的过程与构建 DOM 的过程非常相似，当浏览器接收到一段 CSS，浏览器首先要做的是识别出 Token，然后构建节点并生成 CSSOM。</p> <p>在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是<strong>很消耗资源</strong>的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归 CSSOM 树，然后确定具体的元素到底是什么样式。</p> <p><strong>注意：CSS 匹配 HTML 元素是一个相当复杂和有性能问题的事情。所以，DOM 树要小，CSS 尽量用 id 和 class，千万不要过渡层叠下去。</strong></p> <h3 id="构建渲染树（rendering-tree）"><a href="#构建渲染树（rendering-tree）" class="header-anchor">#</a> 构建渲染树（Rendering Tree）</h3> <p>生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。</p> <p>在这一过程中，不是简单的将两者合并。<strong>渲染树只会包括需要显示的节点和这些节点的样式信息</strong>，如果某个节点是<code>display:none</code>的，那么就不会在渲染树中显示。</p> <h4 id="浏览器如果渲染过程中遇到-js-文件怎么处理"><a href="#浏览器如果渲染过程中遇到-js-文件怎么处理" class="header-anchor">#</a> 浏览器如果渲染过程中遇到 JS 文件怎么处理</h4> <p>渲染过程中，如果遇到 <code>&lt;script&gt;</code>(此处指没有添加<em>defer</em>或者<em>async</em>属性)就停止渲染，执行 JS 代码。因为浏览器渲染和 JS 执行共用一个线程，而且<strong>这里必须是单线程操作，多线程会产生渲染 DOM 冲突</strong>。JavaScript 的<em>加载</em>、<em>解析</em>与<em>执行</em>会阻塞 DOM 的构建，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停构建 DOM，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复 DOM 构建。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>在 script 标签没有添加<em>defer</em>或者<em>async</em>属性的情况下，如果想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，此时应将 script 标签放在 body 标签底部</p></div> <h4 id="async-和-defer-的作用与区别"><a href="#async-和-defer-的作用与区别" class="header-anchor">#</a> async 和 defer 的作用与区别</h4> <p>1）情况 1 <code>&lt;scriptsrc=&quot;script.js&quot;&gt;&lt;/script&gt;</code>（<strong>阻塞</strong>）</p> <p>没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。</p> <p>2）情况 2 <code>&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;</code> (<strong>异步下载，阻塞 load</strong>)</p> <p>async 属性表示异步执行引入的 JavaScript，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。</p> <blockquote><p>这种方式加载的 JavaScript 依然会阻塞 load 事件。因为，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。</p></blockquote> <p>3）情况 3 <code>&lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt;</code>(<strong>延迟执行</strong>)</p> <p>defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>defer 与相比 async，有两点区别：加载完 JavaScript，不会立即执行，执行阶段被放到 HTML 标签解析完成之后；在加载多个 JS 脚本的时候，async 是<strong>无顺序</strong>的加载，而 defer 是<strong>有顺序</strong>的加载。</p></div> <h4 id="js-文件不只是阻塞-dom-的构建，它会导致-cssom-也阻塞-dom-的构建"><a href="#js-文件不只是阻塞-dom-的构建，它会导致-cssom-也阻塞-dom-的构建" class="header-anchor">#</a> JS 文件不只是阻塞 DOM 的构建，它会导致 CSSOM 也阻塞 DOM 的构建</h4> <p>因为 JavaScript 不只是可以改 DOM，它还可以更改样式，即它可以更改 CSSOM。<strong>而不完整的 CSSOM 是无法使用的</strong>，如果 JavaScript 想访问 CSSOM 并更改它，那么在执行 JavaScript 时，必须要能拿到<strong>完整的 CSSOM</strong>。所以就导致了一个现象，如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和 DOM 构建，直至其完成 CSSOM 的下载和构建。也就是说，<strong>在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后在继续构建 DOM</strong>。</p> <h3 id="布局与绘制"><a href="#布局与绘制" class="header-anchor">#</a> 布局与绘制</h3> <p>当浏览器生成渲染树以后，就会根据渲染树来进行布局（又称做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排“。</p> <p>布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸，所有相对测量值都将转换为屏幕上的绝对像素。</p> <p>布局完成后，浏览器会立即发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素。</p> <h3 id="补充说明"><a href="#补充说明" class="header-anchor">#</a> 补充说明</h3> <h4 id="_1、为什么操作-dom-慢"><a href="#_1、为什么操作-dom-慢" class="header-anchor">#</a> 1、为什么操作 DOM 慢</h4> <blockquote><p>把 DOM 和 JavaScript 各自想象成一个岛屿，它们之间用收费桥梁连接。——《高性能 JavaScript》</p></blockquote> <p>JS 是很快的，在 JS 中修改 DOM 对象也是很快的。在 JS 的世界里，一切是简单的、迅速的。<strong>但 DOM 操作并非 JS 一个人的独舞，而是两个模块之间的协作</strong>。</p> <p>因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。<strong>当我们用 JS 去操作 DOM 时，本质上是 JS 引擎和渲染引擎之间进行了“跨界交流”</strong>。这个“跨界交流”的实现并不简单，它依赖了桥接接口作为“桥梁”，而过“桥”要收费——这个开销本身就是不可忽略的。我们每操作一次 DOM（不管是为了修改还是仅仅为了访问其值），都要过一次“桥”。过“桥”的次数一多，就会产生比较明显的性能问题。因此“减少 DOM 操作”的建议，并非空穴来风。</p> <h4 id="_2、关于回流和重绘"><a href="#_2、关于回流和重绘" class="header-anchor">#</a> 2、关于回流和重绘</h4> <ul><li><p>重绘 Repaint：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式</p></li> <li><p>回流 Reflow：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）</p></li></ul> <p>网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断重新渲染。重新渲染会重复回流+重绘或者只有重绘。<strong>回流必定会发生重绘，重绘不一定会引发回流</strong>。</p> <p>重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。</p> <h5 id="常见引起回流属性和方法"><a href="#常见引起回流属性和方法" class="header-anchor">#</a> 常见引起回流属性和方法</h5> <p>任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发回流，</p> <ul><li>添加或者删除可见的 DOM 元素；</li> <li>元素尺寸改变——边距、填充、边框、宽度和高度</li> <li>内容变化，比如用户在 input 框中输入文字</li> <li>浏览器窗口尺寸改变——resize 事件发生时</li> <li>计算 offsetWidth 和 offsetHeight 属性</li> <li>设置 style 属性的值</li></ul> <table><thead><tr><th>Attribute&amp;Methods</th> <th></th> <th></th> <th></th></tr></thead> <tbody><tr><td>width</td> <td>height</td> <td>margin</td> <td>padding</td></tr> <tr><td>display</td> <td>border</td> <td>position</td> <td>overflow</td></tr> <tr><td>clientWidth</td> <td>clientHeight</td> <td>clientTop</td> <td>clientLeft</td></tr> <tr><td>offsetWidth</td> <td>offsetHeight</td> <td>offsetTop</td> <td>offsetLeft</td></tr> <tr><td>scrollWidth</td> <td>scrollHeight</td> <td>scrollTop</td> <td>scrollLeft</td></tr> <tr><td>scrollIntoView()</td> <td>scrollTo()</td> <td>getComputedStyle()</td> <td></td></tr> <tr><td>getBoundingClientRect()</td> <td>scrollIntoViewIfNeeded()</td> <td></td> <td></td></tr></tbody></table> <h5 id="常见引起重绘属性和方法"><a href="#常见引起重绘属性和方法" class="header-anchor">#</a> 常见引起重绘属性和方法</h5> <table><thead><tr><th>Attribute&amp;Methods</th> <th></th> <th></th> <th></th></tr></thead> <tbody><tr><td>color</td> <td>border-style</td> <td>visibility</td> <td>background</td></tr> <tr><td>text-decoration</td> <td>background-image</td> <td>background-position</td> <td>background-repeat</td></tr> <tr><td>outline-color</td> <td>outline</td> <td>outline-style</td> <td>border-radius</td></tr> <tr><td>outline-width</td> <td>box-shadow</td> <td>background-size</td> <td></td></tr></tbody></table> <h5 id="浏览器的渲染队列"><a href="#浏览器的渲染队列" class="header-anchor">#</a> 浏览器的渲染队列</h5> <div class="language-js extra-class"><pre class="language-js"><code>div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token string">&quot;10px&quot;</span><span class="token punctuation">;</span>
div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> <span class="token string">&quot;10px&quot;</span><span class="token punctuation">;</span>
div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>width <span class="token operator">=</span> <span class="token string">&quot;20px&quot;</span><span class="token punctuation">;</span>
div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token string">&quot;20px&quot;</span><span class="token punctuation">;</span>
</code></pre></div><p>这段代码理论上会触发 4 次重排+重绘，因为每一次都改变了元素的几何属性。实际上，这最后只触发了一次重排，这都得益于浏览器的渲染队列机制：当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行这些操作。</p> <h5 id="如何减少回流、重绘"><a href="#如何减少回流、重绘" class="header-anchor">#</a> 如何减少回流、重绘</h5> <ul><li>使用 transform 替代 top</li> <li>使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li> <li>不要把节点的属性值放在一个循环里当成循环里的变量</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取 offsetTop 会导致回流，因为需要去获取正确的值</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.test'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>offsetTop<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局</li> <li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame</li> <li>CSS 选择符从右往左匹配查找，避免节点层级过多</li> <li>将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层。</li></ul> <h3 id="性能优化策略"><a href="#性能优化策略" class="header-anchor">#</a> 性能优化策略</h3> <ul><li>JS优化：<code>&lt;script&gt;</code>标签加上<em>defer</em>属性和<em>async</em>属性 用于在不阻塞页面文档解析的前提下，控制脚本的下载和执行。 defer属性： 用于开启新的线程下载脚本文件，并使脚本在文档解析完成后执行。 async属性： HTML5新增属性，用于异步下载脚本文件，下载完毕立即解释执行代码。</li> <li>CSS优化：<code>&lt;link&gt;</code> 标签的 rel属性 中的属性值设置为<em>preload</em>能够让你在你的HTML页面中可以指明哪些资源是在页面加载完成后即刻需要的,最优的配置加载顺序，提高渲染性能</li></ul> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <ul><li>浏览器工作流程：构建DOM -&gt; 构建CSSOM -&gt; 构建渲染树 -&gt; 布局 -&gt; 绘制。</li> <li>CSSOM会阻塞渲染，只有当CSSOM构建完毕后才会进入下一个阶段构建渲染树。</li> <li>通常情况下DOM和CSSOM是并行构建的，但是当浏览器遇到一个不带defer或async属性的script标签时，DOM构建将暂停，如果此时又恰巧浏览器尚未完成CSSOM的下载和构建，由于JavaScript可以修改CSSOM，所以需要等CSSOM构建完毕后再执行JS，最后才重新DOM构建。</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/mblog/assets/js/app.b34711a8.js" defer></script><script src="/mblog/assets/js/2.1254f33f.js" defer></script><script src="/mblog/assets/js/14.1f383059.js" defer></script><script src="/mblog/assets/js/4.4f648c2b.js" defer></script>
  </body>
</html>
